<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>emacs on bram85</title><link>https://www.bram85.nl/tags/emacs/</link><description>bram85 (emacs)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 May 2022 08:04:00 +0200</lastBuildDate><atom:link href="https://www.bram85.nl/tags/emacs/index.xml" rel="self" type="application/rss+xml"/><item><title>Use tab-bar-history-mode instead of winner-mode</title><link>https://www.bram85.nl/posts/use-tab-bar-history-instead-of-winner-mode/</link><pubDate>Sat, 21 May 2022 08:04:00 +0200</pubDate><guid>https://www.bram85.nl/posts/use-tab-bar-history-instead-of-winner-mode/</guid><description>&lt;p>&lt;code>winner-mode&lt;/code> is a minor mode in Emacs which remembers your window configurations. You can go back to an older window configuration, by default with &lt;em>C-c &amp;lt;left&amp;gt;&lt;/em> (and &lt;em>C-c &amp;lt;right&amp;gt;&lt;/em> to move forward). However, &lt;code>winner-mode&lt;/code> is tab-unaware, which messes up your window configuration when you&amp;rsquo;ve switched tabs in the meantime. Luckily, there is &lt;code>tab-bar-history-mode&lt;/code> which does the same, except it stores the window configuration per tab. By using the same bindings as &lt;code>winner-mode&lt;/code> it becomes a drop-in replacement.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elisp" data-lang="elisp">&lt;span style="display:flex;">&lt;span>(use-package tab-bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (tab-bar-history-mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :bind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;C-c &amp;lt;left&amp;gt;&amp;#34;&lt;/span> &lt;span style="color:#f92672">.&lt;/span> tab-bar-history-back)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;C-c &amp;lt;right&amp;gt;&amp;#34;&lt;/span> &lt;span style="color:#f92672">.&lt;/span> tab-bar-history-forward))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that &lt;code>tab-bar-history-back&lt;/code> and &lt;code>tab-bar-history-forward&lt;/code> do not behave well when called interactively from a minibuffer window. The minibuffer may actually change the window configuration, pushing one to the history, which results in &lt;code>tab-bar-history-back&lt;/code> popping the window configuration you were looking at in the first place, so essentially becoming a no-op. By binding these functions to some keys, the functions behave as they should.&lt;/p></description></item><item><title>Enable history expansion with eshell</title><link>https://www.bram85.nl/posts/enable-history-expansion-with-eshell/</link><pubDate>Fri, 06 May 2022 16:27:00 +0200</pubDate><guid>https://www.bram85.nl/posts/enable-history-expansion-with-eshell/</guid><description>&lt;p>For some reason, history expansion through &lt;code>!&lt;/code> notation is not enabled by default in Emacs eshell. The variable &lt;code>eshell-expand-input-functions&lt;/code> needs to be extended as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elisp" data-lang="elisp">&lt;span style="display:flex;">&lt;span>(add-to-list &lt;span style="color:#e6db74">&amp;#39;eshell-expand-input-functions&lt;/span> &lt;span style="color:#e6db74">&amp;#39;eshell-expand-history-references&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or, to be specific, add it to the &lt;code>eshell-hist-load-hook&lt;/code> otherwise the addition operation may complain that the list does not exist when eshell hasn&amp;rsquo;t loaded yet. An example is shown below if you use &lt;code>use-package&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elisp" data-lang="elisp">&lt;span style="display:flex;">&lt;span>(use-package eshell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :commands eshell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :hook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (eshell-hist-load &lt;span style="color:#f92672">.&lt;/span> (lambda () (add-to-list &lt;span style="color:#e6db74">&amp;#39;eshell-expand-input-functions&lt;/span> &lt;span style="color:#e6db74">&amp;#39;eshell-expand-history-references&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Emacs Lisp: Expand macros</title><link>https://www.bram85.nl/posts/emacs-lisp-expand-macros/</link><pubDate>Wed, 27 Apr 2022 21:02:00 +0200</pubDate><guid>https://www.bram85.nl/posts/emacs-lisp-expand-macros/</guid><description>&lt;p>To expand a macro, the &lt;code>pp-macroexpand-last-sexp&lt;/code> is a useful function. It&amp;rsquo;s like &lt;code>pp-eval-last-sexp&lt;/code>, but opens a new buffer with the expanded code without evaluation.&lt;/p>
&lt;p>For example, it&amp;rsquo;s easy to inspect the magic behind &lt;code>use-package&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elisp" data-lang="elisp">&lt;span style="display:flex;">&lt;span>(use-package org)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>is transformed by &lt;code>pp-macroexpand-last-sexp&lt;/code> to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elisp" data-lang="elisp">&lt;span style="display:flex;">&lt;span>(progn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (straight-use-package &lt;span style="color:#e6db74">&amp;#39;org&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (defvar use-package--warning117
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">#&amp;#39;&lt;/span>(lambda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (keyword err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (let
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((msg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">format&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%s/%s: %s&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;org&lt;/span> keyword
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">error-message-string&lt;/span> err))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (display-warning &lt;span style="color:#e6db74">&amp;#39;use-package&lt;/span> msg :error))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (condition-case-unless-debug err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (if
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (not
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (require &lt;span style="color:#e6db74">&amp;#39;org&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#66d9ef">t&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (display-warning &lt;span style="color:#e6db74">&amp;#39;use-package&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">format&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Cannot load %s&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;org&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :error))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">funcall&lt;/span> use-package--warning117 :catch err))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course it becomes more elaborate with &lt;code>:config&lt;/code>, &lt;code>:bind&lt;/code>, &lt;code>:hook&lt;/code> flags, but you get the idea.&lt;/p></description></item><item><title>There is a consult-ag package</title><link>https://www.bram85.nl/posts/consult-ag-package/</link><pubDate>Tue, 26 Apr 2022 15:48:00 +0200</pubDate><guid>https://www.bram85.nl/posts/consult-ag-package/</guid><description>&lt;p>A new package appeared on MELPA: &lt;a href="https://github.com/yadex205/consult-ag">consult-ag&lt;/a>, similar to &lt;code>consult-grep&lt;/code> and &lt;code>consult-ripgrep&lt;/code> but then for &lt;a href="https://github.com/ggreer/the_silver_searcher">The Silver Searcher&lt;/a>. Glad it&amp;rsquo;s here because my attempt to add &lt;code>ag&lt;/code> support failed.&lt;/p></description></item><item><title>Emacs</title><link>https://www.bram85.nl/posts/chirp-emacs-emacs/</link><pubDate>Tue, 26 Apr 2022 15:01:00 +0200</pubDate><guid>https://www.bram85.nl/posts/chirp-emacs-emacs/</guid><description>&lt;p>Observation: Emacs is primarily used to configure Emacs.&lt;/p></description></item></channel></rss>